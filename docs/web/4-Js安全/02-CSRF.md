---
meta:
  - name: description
    content: 前端跨站请求伪造
  - name: keywords
    content: 前端跨站请求伪造,跨站请求伪造,前端,攻击,CSRF
---
# 跨站请求伪造

## 1. 介绍

CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。

攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

**CSRF攻击原理及过程如下：**

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；

5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

![CSRF攻击过程](/img/CSRF攻击过程.png)

## 2. 攻击对象

在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。

CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。

所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。

比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。

## 3. 特点

+ 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。

+ 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。

+ 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。

+ 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

## 4. 防范措施

上文中讲了CSRF的两个特点：

+ CSRF（通常）发生在第三方域名

+ CSRF攻击者不能获取到Cookie等信息，只是使用

针对这两点，我们可以专门制定防护策略：

+ 阻止不明外域的访问

+ 提交时要求附加本域才能获取的信息

### 4.1 验证 HTTP Referer 字段

根据 HTTP 协议，在 HTTP 头中有一个字段叫 `Referer`，它记录了该 HTTP 请求的来源地址。也就是说，服务器会验证客户端的请求来源，如果本网站请求的则响应，否则不响应。

但是即使这样，验证 HTTP Referer 字段 这种方式也存在安全隐患

1. 对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值

2. 用户自己可以设置浏览器使其在发送请求时不再提供 Referer

### 4.2 使用 token （Anti CSRF Token）

当我们向服务器请求资源的时候，服务器返回资源的同时向客户端下发一个token，客户端在每次请求的时候都需要带上这个token。服务器在收到请求后会先验证这个token的有效性。如果有效，会成功响应。否则，会拒绝响应。

这个token可以看作是客户端和服务器之间的一个凭证，所以，是不能让第三方知道的。一般我们可以将token保存在用户的session或者浏览器的cookie中。

### 4.3 SameSite限制

Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。

Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。

它可以设置三个值。

+ Strict
+ Lax
+ None

#### 4.4 Strict

Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。

#### 4.5 Lax

Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。

```html
<a href="..."></a>
<link rel="prerender" href="..."/>
<form method="GET" action="...">
```

设置了Strict或Lax以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性

#### 4.6 None

Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效

## 5. 参考资料

[web安全之csrf攻击](https://zhaosaisai.com/blog/2018/web%E5%AE%89%E5%85%A8%E4%B9%8Bcsrf%E6%94%BB%E5%87%BB.html)

[CSRF攻击防御原理](https://www.freebuf.com/articles/web/224446.html)

[前端安全系列之二：如何防止CSRF攻击？](https://juejin.im/post/5bc009996fb9a05d0a055192)

[SameSite cookies](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite)
