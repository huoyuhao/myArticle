---
meta:
  - name: description
    content: 前端跨站请求伪造
  - name: keywords
    content: 前端跨站请求伪造,跨站请求伪造,前端,攻击,CSRF
---
# 跨站请求伪造

## 1. 介绍

CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。

攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

**CSRF攻击原理及过程如下：**

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；

5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

![CSRF攻击过程](/img/CSRF攻击过程.png)

**这里列举Cookie主要的一些特性：**

1. 浏览器默认自动携带本次HTTP请求域名的Cookie（不管是通过什么方式，在什么页面发送的HTTP请求）

2. 读写Cookie有跨域限制(作用域，Domain,Path)

3. 生命周期(会话or持久)

## 2. 攻击对象

在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。

CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。

所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。

比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。

## 3. 特点

+ 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。

+ 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。

+ 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。

+ 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

## 4. 防范措施

上文中讲了CSRF的两个特点：

+ CSRF（通常）发生在第三方域名

+ CSRF攻击者不能获取到Cookie等信息，只是使用

针对这两点，我们可以专门制定防护策略：

+ 阻止不明外域的访问

+ 提交时要求附加本域才能获取的信息

### 4.1 验证 HTTP Referer 字段

根据 HTTP 协议，在 HTTP 头中有一个字段叫 `Referer`，它记录了该 HTTP 请求的来源地址。也就是说，服务器会验证客户端的请求来源，如果本网站请求的则响应，否则不响应。

处理了下面几种特殊情况，用Referrer防CSRF是安全

+ 读操作不能有上面提到提到的两种特殊情况，不能用JSONP，CORS要白名单，所以读操作是安全的。
+ 写操作Referrer为空的时候不能放过，使用白名单机制，Referrer在白名单内才放过。什么时候会为空？
  + 地址栏直接输入url的时候，第一个请求Referrer为空，一般是html页面，这种读操作不用防CSRF
  + 使用Referrer-Policy策略设置no-referrer是，Referrer为空，自己的页面不要这样设置，为了防黑客的页面设置了，所以为空的时候不能放过。
  + 还有一些iframe的特殊使用(以前用来绕过图片防盗链的)也会导致Referrer为空，这些情况都不能放过过。
+ 写操作不能用Get，如果写操作可以用Get，由于Img标签，A标签能发Get请求。所以在一些UGC网站，比如用户写日志可以插入自定义图片，能插入自定义连接，图片img标签src或者A标签的href就指向写操作的URL，这样只要打开这篇日志就会发送这个Get请求，或者点击了日志上的连接，就帮用户做了写操作。并且Referrer还是合法的。这就是一种少见的CSRF攻击过程，其实也是最早期的CSRF攻击。这种攻击一旦成功，很方便做成蠕虫病毒，危害性极大。PS有人觉得这种少见的攻击过程不算CSRF，应该算XSS，好像也有点道理，但是常规的防XSS的方法貌似不好防这种特殊情况，下面要讲的CSRF的Token的防护方式是能防这种特殊情况的。

**同理适用Origin：**

原理跟Referrer一样，Origin请求头是XHR2.0里增加的，含义是发送请求页面的域名，主要目的是解决跨域问题。如果用来校验CSRF请求，就有一些细节要处理好，后台判断Origin时也要使用白名单，并且不能为空，不在白名单内的请求都直接返回失败，不能执行请求里的写操作(有一些web server是请求执行了，也返回了数据，只是没有配ACAO响应头，浏览器收不到，这种情况能限制跨域请求，但是不能防CSRF的写操作)。另外一种做法就是自定义HTTP请求头，把HTTP请求升级为复杂请求，这样在跨域情况下就会先发一个Option预检请求，预检请求通不过也就不会执行后面真实请求了。

### 4.2 使用 token （Anti CSRF Token）

当我们向服务器请求资源的时候，服务器返回资源的同时向客户端下发一个token，客户端在每次请求的时候都需要带上这个token。服务器在收到请求后会先验证这个token的有效性。如果有效，会成功响应。否则，会拒绝响应。

1. 后端随机产生一个token，基于这个token通过SHA-56等散列算法生成一个密文；
2. 后端将这个token和生成的密文都设置为cookie，返回给前端；
3. 前端需要发起请求的时候，从cookie中获取token，把这个token加入到请求数据或者头信息中，一起传给后端；
4. 后端校验cookie中的密文，以及前端请求带过来的token，进行正向散列验证；

+ 这个token可以看作是客户端和服务器之间的一个凭证，所以，是不能让第三方知道的（放localStorage、session中都可以）；
+ 一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用；
+ 散列算法都是需要计算的，这里会有性能风险；
+ token参数必须由前端处理之后交给后端，而不能直接通过cookie；

**Token放在HTTP参数位置：**

+ Token放在URL的querystring里，Post请求的Data里或者HTTP请求头里，这三种方式都可以
+ 如果querystring里，可能会影响Get请求的缓存效果，因为重新登录之后token会变，url也就变了，之前的缓存就失效了。
+ 如果放在HTTP请求头里，就需要使用fetch或者XHR发请求，这样会变成复杂请求，跨域情况需要多一次Option预检请求，对性能多少有一点点影响。

### 4.3 SameSite限制

Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。

Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险，**但是客户端对SameSite属性的支持并不是特别好**

它可以设置三个值。

+ Strict
+ Lax
+ None

#### 4.3.1 Strict

Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。

#### 4.3.2 Lax

Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。

```html
<a href="..."></a>
<link rel="prerender" href="..."/>
<form method="GET" action="...">
```

设置了Strict或Lax以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性

#### 4.3.3 None

Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效

## 5. 参考资料

[web安全之csrf攻击](https://zhaosaisai.com/blog/2018/web%E5%AE%89%E5%85%A8%E4%B9%8Bcsrf%E6%94%BB%E5%87%BB.html)

[CSRF攻击防御原理](https://www.freebuf.com/articles/web/224446.html)

[前端安全系列之二：如何防止CSRF攻击？](https://juejin.im/post/5bc009996fb9a05d0a055192)

[SameSite cookies](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite)
