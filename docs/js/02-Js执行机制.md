---
meta:
  - name: description
    content: JavaScript执行机制
  - name: keywords
    content: JavaScript执行机制,Js作用域链,JavaScript,前端,作用域,作用域链
---
# JavaScript执行机制

## 作用域
> 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

+ ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。
+ ES6的到来，为我们提供了‘块级作用域’,可通过新增命令let和const来体现。
+ 作用域与执行上下文是完全不同的两个概念。
+ 作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

1. 全局作用域：在最外层函数定义的变量即拥有全局作用域，对于任意函数来说，都可以访问到。
+ 最外层函数 和在最外层函数外面定义的变量拥有全局作用域
+ 所有末定义直接赋值的变量自动声明为拥有全局作用域
+ 所有window对象的属性拥有全局作用域，例如window.name、window.location、window.top等等
```js
{
  var a = 1 
  var fn = function () {
    console.log(a) // 1
  }
  fn()
}
```
2. 局部作用域：和全局作用域相反，局部作用域的变量即是在特定代码块中才能过访问，对于外部是不能够访问的。注意：在函数内部定义变量的时候，如果不用var，那么你声明的就是全局变量了。
```js
{
  var a = 1
  var fn = function () {
      var b = 2
      console.log(a) // 1
  }
  fn()
  console.log(b) // b is not defined
}
```
3. 块级作用域：在代码块中使用let定义的变量，只能在当前代码块中进行访问。块级作用域可以形成暂时性死区。
+ 块级作用域在如下情况被创建：在一个函数内部或者在一个代码块（由一对花括号包裹）内部
+ let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。
+ 如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。
```js
var fn = function () {
  for(let i = 0; i < 10; i++) {
    console.log(i) // 1-9
  }
  console.log(i) // undefined
}
fn()
```
**作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行**

## 变量提升

### JavaScript 中的声明和赋值
1. 变量的声明和赋值
```js
var name = 'yuhoo'
// 等同于
var name    //声明部分
name = 'yuhoo'  //赋值部分
```
2. 函数的声明和赋值
```js
function foo () {
  console.log('foo')
}

var bar = function () {
  console.log('bar')
}
```
+ 第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；
+ 第二个函数是先声明变量 bar，再把`function(){console.log('bar')}`赋值给 bar

**所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined**

```js
showName()
console.log(name)
var name = 'yuhoo'
function showName () {
  console.log('函数showName被执行')
}
// 等同于

/*
* 变量提升部分
*/
// 把变量 name 提升到开头，
// 同时给 name 赋值为undefined
var name = undefined
// 把函数showName提升到开头
function showName () {
  console.log('函数showName被执行')
}
/*
* 可执行代码部分
*/
showName()
console.log(name)
// 去掉var声明部分，保留赋值语句
name = 'yuhoo'
```
**函数和变量在执行之前都提升到了代码开头**

## 执行流程
**实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。**

一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

### 1. 编译阶段
![Js执行机制](/img/Js执行机制-1.png)

经过编译后，会生成两部分内容：**执行上下文（Execution context）和可执行代码。**

**执行上下文是 JavaScript 执行一段代码时的运行环境**，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

在执行上下文中存在一个**变量环境的对象（Viriable Environment）**，该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName

结合下面这段代码来分析下是如何生成变量环境对象的:
```js
showName()
console.log(name)
var name = 'yuhoo'
function showName () {
  console.log('函数showName被执行')
}
```
+ 第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；
+ 第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 name 的属性，并使用 undefined 对其初始化；
+ 第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置。

这样就生成了变量环境对象。接下来 JavaScript 引擎会把声明以外的代码编译为字节码




### 2. 执行阶段
JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程：
+ 当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。
+ 接下来打印“name”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 name 变量，并且其值为 undefined，所以这时候就输出 undefined。
+ 接下来执行第 3 行，把“yuhoo”赋给 name 变量，赋值后变量环境中的 name 属性值改变为“yuhoo”


## 代码中出现相同的变量或者函数
```js
showName()
var showName = function () {
  console.log(2)
}
function showName () {
  console.log(1)
}

//编译阶段:
var showName
function showName () { console.log(1) }

//执行阶段:
showName() // 输出1
showName = function () { console.log(2) }
// 如果后面再有showName执行的话，就输出2因为这时候函数引用已经变了
```

**一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数**



## 作用域链
作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。

```js
var x = 10
function fn () {
  console.log(x)
}
function show (f) {
  var x = 20
  (function() {
    f() //10，而不是20
  })()
}
show(fn)
```
在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取，无论fn函数将在哪里调用。
相比而言，用这句话描述会更加贴切:**要到创建这个函数的那个域”。作用域中取值,这里强调的是“创建”，而不是“调用”**
```js
var a = 10
var b = 200
function fn () {
  var b = 20
  function bar () {
    console.log(a + b) // 30
  }
  return bar
}
var x = fn()
x() // bar()
```


### 延长作用域链
有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况下会发生这种现象。
+ try-catch 语句中的 catch 块
+ with 语句
对 with 来说，将会指定对象添加到作用域链中。对 catch 来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。


## 参考资料
[极客时间课程 -- 浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601)

[深入理解JavaScript作用域和作用域链](https://juejin.im/post/5c8290455188257e5d0ec64f)