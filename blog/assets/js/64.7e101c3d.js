(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{417:function(t,n,e){"use strict";e.r(n);var r=e(25),o=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"跨站脚本攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跨站脚本攻击"}},[t._v("#")]),t._v(" 跨站脚本攻击")]),t._v(" "),e("h2",{attrs:{id:"_1-介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-介绍"}},[t._v("#")]),t._v(" 1. 介绍")]),t._v(" "),e("ul",[e("li",[t._v("CommonJS\n通过require引入基础数据类型时，属于复制该变量。\n通过require引入复杂数据类型时，数据浅拷贝该对象\n出现模块之间的循环引用时，会输出已经执行的模块，而未执行的模块不输出（比较复杂）\nCommonJS模块默认export的是一个对象，即使导出的是基础数据类型")])]),t._v(" "),e("p",[t._v("ES6模块\n不管是基础（复杂）数据类型，都只是对该变量的动态只读引用。动态在于一个模块中变量的变化会影响到另一个模块；\n只读在于从某个模块引入一个变量时，不允许修改该变量的值。对于复杂数据类型，可以添加属性和方法，但是不允许指向另一个内存空间。\n出现模块之间的循环引用时，只要模块存在某个引用，代码就能够执行。")]),t._v(" "),e("p",[t._v("循环引入\nCommonJS 模块\n所有代码运行在模块作用域，不会污染全局作用域\n模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n模块加载的顺序，按照其在代码中出现的顺序")]),t._v(" "),e("p",[t._v("CommonJs模块输出的是一个值的拷贝，ES6模块输出的是值的引用。\nCommonJs模块是运行时加载，ES6模块是编译时输出接口。\n导入require 导出 exports/module.exports 是 CommonJS 的标准，通常适用范围如 Node.js\nimport/export 是 ES6 的标准，通常适用范围如 React\nrequire 是赋值过程并且是运行时才执行，也就是同步加载\nrequire 可以理解为一个全局方法，因为它是一个方法所以意味着可以在任何地方执行。\nimport 是解构过程并且是编译时执行，理解为异步加载\nimport 会提升到整个模块的头部，具有置顶性，但是建议写在文件的顶部。")]),t._v(" "),e("p",[t._v("commonjs 输出的，是一个值的拷贝，而es6输出的是值的引用；")]),t._v(" "),e("p",[t._v("commonjs 是运行时加载，es6是编译时输出接口；")]),t._v(" "),e("h2",{attrs:{id:"_4-参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-参考资料"}},[t._v("#")]),t._v(" 4. 参考资料")]),t._v(" "),e("p",[t._v("https://juejin.cn/post/7004789285886885924\nhttps://www.zhihu.com/question/56820346")])])}),[],!1,null,null,null);n.default=o.exports}}]);