(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{372:function(t,a,e){"use strict";e.r(a);var s=e(25),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"前端浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端浏览器缓存"}},[t._v("#")]),t._v(" 前端浏览器缓存")]),t._v(" "),e("p",[t._v("浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。我想几乎每个开发者都碰到过缓存的问题吧，甚至有很多情况下我们会说这个问题已经修复了，你清理下缓存就好了。这篇文章我们就细细的来挖掘下缓存的种种轶事。")]),t._v(" "),e("h2",{attrs:{id:"缓存介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存介绍"}},[t._v("#")]),t._v(" 缓存介绍")]),t._v(" "),e("p",[e("strong",[t._v("缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。")])]),t._v(" "),e("p",[t._v("很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。")]),t._v(" "),e("p",[t._v("实际上所谓的缓存只有一种——Web缓存。它是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。HTTP协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要了解熟悉的对象，研究下究竟是哪些字段怎么影响缓存的。")]),t._v(" "),e("h2",{attrs:{id:"缓存规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存规则"}},[t._v("#")]),t._v(" 缓存规则")]),t._v(" "),e("p",[t._v("http缓存规则由响应首部字段进行控制，其中的关键字段有"),e("code",[t._v("Expires、Cache-Control、Last-Modified、Etag")]),t._v("四个字段。Expires和Cache-Control用来确定确定缓存的存储时间，Last-Modified 和Etag则用来确定缓存是否要被更新。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("关键字段")]),t._v(" "),e("th",[t._v("描述")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("Expires")]),t._v(" "),e("td",[t._v("HTTP1.0中用来控制缓存时间的参数，绝对时间， 即在此时间之后，响应过期。")])]),t._v(" "),e("tr",[e("td",[t._v("Cache-Control")]),t._v(" "),e("td",[t._v("HTTP1.1中用来控制缓存时间的参数，相对时间。")])]),t._v(" "),e("tr",[e("td",[t._v("Last-Modified")]),t._v(" "),e("td",[t._v("源头服务器认定的资源做出修改的日期及时间。")])]),t._v(" "),e("tr",[e("td",[t._v("Etag")]),t._v(" "),e("td",[t._v("HTTP响应头是资源的特定版本的标识符。")])])])]),t._v(" "),e("h2",{attrs:{id:"缓存流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存流程"}},[t._v("#")]),t._v(" 缓存流程")]),t._v(" "),e("p",[t._v("目前主流的浏览器缓存分为两类，强缓存和协商缓存，它们的匹配流程如下：")]),t._v(" "),e("ul",[e("li",[t._v("浏览器发送请求前，根据请求头的expires和cache-control判断是否命中强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。")]),t._v(" "),e("li",[t._v("没有命中强缓存规则，浏览器会发送请求，根据请求头的last-modified和etag判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。")]),t._v(" "),e("li",[t._v("如果前两步都没有命中，则直接从服务端获取资源。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86.png",alt:"浏览器缓存原理"}})]),t._v(" "),e("h2",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),e("h3",{attrs:{id:"_1、强缓存配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、强缓存配置"}},[t._v("#")]),t._v(" 1、强缓存配置")]),t._v(" "),e("p",[t._v("强缓存可以通过服务端设置expires和cache-control来控制。")]),t._v(" "),e("div",{staticClass:"language-php line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-php"}},[e("code",[t._v("server "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  listen "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  server_name www"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("liam"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("huoyuhao"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  root "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("www"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("liamTest"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  index index"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("html"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  charset utf"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  location "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\\"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("gif"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("jpg"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("png"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    expires "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("s"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    add_header wall "),e("span",{pre:!0,attrs:{class:"token double-quoted-string string"}},[t._v('"hello liam!!!"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")])]),e("h3",{attrs:{id:"强缓存响应头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存响应头"}},[t._v("#")]),t._v(" 强缓存响应头")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BF%A1%E6%81%AF.png",alt:"强缓存响应头信息"}})]),t._v(" "),e("p",[t._v("（1）expires：从图可以看出，expires的值是一个绝对时间，是"),e("code",[t._v("http1.0")]),t._v("的功能。如果浏览器的时间没有超过这个expires的时间，代表缓存还有效，命中强缓存，直接从缓存读取资源。不过由于存在浏览器和服务端时间可能出现较大误差，所以在之后http1.1提出了cache-control。")]),t._v(" "),e("p",[t._v("（2）cache-control：从图可以看出，cache-control的值是类似于max-age=10这样的，是一个相对时间，10是秒数。当浏览器第一次请求资源的时候，会把response header的内容缓存下来。之后的请求会先从缓存检查该response header，通过第一次请求的date和cache-control计算出缓存有效时间。如果浏览器的时间没有超过这个缓存有效的时间，代表缓存还有效，命中强缓存，直接从缓存读取资源。")]),t._v(" "),e("p",[e("strong",[t._v("两者可以同时设置，但是优先级cache-control > expires。")])]),t._v(" "),e("h3",{attrs:{id:"强缓存作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存作用"}},[t._v("#")]),t._v(" 强缓存作用")]),t._v(" "),e("p",[t._v("强缓存作为性能优化中缓存方面最有效的手段，能够极大的提升性能。由于强缓存不会向服务端发送请求，对服务端的压力也是大大减小。对于不太经常变更的资源，可以设置一个超长时间的缓存时间，比如一年。浏览器在首次加载后，都会从缓存中读取。\n但是由于不会向服务端发送请求，那么如果资源有更改的时候，怎么让浏览器知道呢？现在常用的解决方法是加一个?v=xxx的后缀，在更新静态资源版本的时候，更新这个v的值，这样相当于向服务端发起一个新的请求，从而达到更新静态资源的目的。（浏览器缓存资源的匹配规则的key是与资源请求URL的全链接相关的，所以更改后缀，浏览器找不到缓存资源）")]),t._v(" "),e("h2",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),e("h3",{attrs:{id:"协商缓存原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存原理"}},[t._v("#")]),t._v(" 协商缓存原理")]),t._v(" "),e("p",[t._v("在强缓存没有命中的时候，就是协商缓存发挥的地盘了。协商缓存会根据[last-modified/if-modified-since]或者[etag/if-none-match]来进行判断缓存是否过期。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BF%A1%E6%81%AF.png",alt:"协商缓存请求头/响应头信息"}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("（1）last-modified/if-modified-since: 浏览器首先发送一个请求，让服务端在response header中返回请求的资源上次更新时间，就是last-modified，浏览器会缓存下这个时间。然后浏览器再下次请求中，request header中带上if-modified-since:[保存的last-modified的值]。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。由于last-modified依赖的是保存的绝对时间，还是会出现误差的情况：一是保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；二是各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。")])]),t._v(" "),e("li",[e("p",[t._v("（2）etag/if-none-match：etag是http协议提供的若干机制中的一种Web缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和last-modified一样，浏览器会先发送一个请求得到etag的值，然后再下一次请求在request header中带上if-none-match:[保存的etag的值]。通过发送的etag的值和服务端重新生成的etag的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。")])])]),t._v(" "),e("p",[t._v("etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的。")]),t._v(" "),e("h3",{attrs:{id:"协商缓存作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存作用"}},[t._v("#")]),t._v(" 协商缓存作用")]),t._v(" "),e("p",[t._v("协商缓存是无法减少请求数的开销的，但是可以减少返回的正文大小。一般来说，对于勤改动的html文件，使用协商缓存是一种不错的选择。")]),t._v(" "),e("h2",{attrs:{id:"刷新缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#刷新缓存"}},[t._v("#")]),t._v(" 刷新缓存")]),t._v(" "),e("p",[t._v("刷新强缓存可以使用?v=xxx的后缀。当然，人工更改版本号的成本比较高，而且难以维护，现在主流的是通过webpack等打包工具生成[name].[hash].js之类的文件名，也能刷新强缓存。")]),t._v(" "),e("p",[t._v("刷新协商缓存比较简单，修改文件内容即可。")]),t._v(" "),e("p",[t._v("对于浏览器而言，在Chrome中，你可以使用审查元素，高版本也叫检查，将Network中的Disable cache打勾，使用cmd+r刷新页面即可。当然你也可以使用强制刷新，直接在页面使用cmd+shift+r进行刷新。")]),t._v(" "),e("h2",{attrs:{id:"其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),e("h3",{attrs:{id:"from-disk-cache和from-memory-cache区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#from-disk-cache和from-memory-cache区别"}},[t._v("#")]),t._v(" from disk cache和from memory cache区别")]),t._v(" "),e("h4",{attrs:{id:"_1）form-memory-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1）form-memory-cache"}},[t._v("#")]),t._v(" 1）form memory cache")]),t._v(" "),e("p",[t._v("不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存当中。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。")]),t._v(" "),e("h4",{attrs:{id:"_2）form-disk-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2）form-disk-cache"}},[t._v("#")]),t._v(" 2）form disk cache")]),t._v(" "),e("p",[t._v("不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如css等。闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。")]),t._v(" "),e("h4",{attrs:{id:"_3）几种状态的执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3）几种状态的执行顺序"}},[t._v("#")]),t._v(" 3）几种状态的执行顺序")]),t._v(" "),e("p",[t._v("现加载一种资源（例如：图片）：")]),t._v(" "),e("p",[t._v("访问-> 200 -> 退出浏览器")]),t._v(" "),e("p",[t._v("再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)")]),t._v(" "),e("h4",{attrs:{id:"_4）不同浏览器策略不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4）不同浏览器策略不同"}},[t._v("#")]),t._v(" 4）不同浏览器策略不同")]),t._v(" "),e("p",[t._v("以上的数据及统计都是在chrome浏览器下进行的")]),t._v(" "),e("p",[t._v("在Firefox下并没有from memory cache以及from disk cache的状态展现")]),t._v(" "),e("h3",{attrs:{id:"cache-control的值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control的值"}},[t._v("#")]),t._v(" Cache-Control的值")]),t._v(" "),e("p",[t._v("1）可缓存性")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("属性")]),t._v(" "),e("th",[t._v("含义")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("public")])]),t._v(" "),e("td",[t._v("表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("private")])]),t._v(" "),e("td",[t._v("表明响应只能被单个用户缓存，不能作为共享缓存（即"),e("strong",[t._v("代理服务器不能缓存它")]),t._v("），可以缓存响应内容")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("no-cache")])]),t._v(" "),e("td",[e("strong",[t._v("在释放缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证")])])]),t._v(" "),e("tr",[e("td",[t._v("only-if-cached")]),t._v(" "),e("td",[t._v("表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝")])])])]),t._v(" "),e("p",[t._v("2）到期")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("属性")]),t._v(" "),e("th",[t._v("含义")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("max-age = number")]),t._v(" "),e("td",[t._v("设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。")])]),t._v(" "),e("tr",[e("td",[t._v("s-maxage = number")]),t._v(" "),e("td",[t._v("覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。")])]),t._v(" "),e("tr",[e("td",[t._v("max-stale[ = number]")]),t._v(" "),e("td",[t._v("表明客户端愿意接收一个已经过期的资源。 可选的设置一个时间(单位秒)，表示响应不能超过的过时时间。")])]),t._v(" "),e("tr",[e("td",[t._v("min-fresh = number")]),t._v(" "),e("td",[t._v("表示客户端希望在指定的时间内获取最新的响应。")])]),t._v(" "),e("tr",[e("td",[t._v("stale-while-revalidate = number")]),t._v(" "),e("td",[t._v("表明客户端愿意接受陈旧的响应，同时在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度。")])]),t._v(" "),e("tr",[e("td",[t._v("stale-if-error = number")]),t._v(" "),e("td",[t._v("表示如果新的检查失败，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。")])])])]),t._v(" "),e("p",[t._v("3）其他")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("属性")]),t._v(" "),e("th",[t._v("含义")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("no-store")])]),t._v(" "),e("td",[e("strong",[t._v("缓存不应存储有关客户端请求或服务器响应的任何内容。")])])]),t._v(" "),e("tr",[e("td",[t._v("no-transform")]),t._v(" "),e("td",[t._v("不得对资源进行转换或转变。Content-Encoding， Content-Range， Content-Type等HTTP头不能由代理修改。例如，非透明代理可以对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。 no-transform指令不允许这样做。")])])])]),t._v(" "),e("p",[t._v("【参考文章】")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.im/post/5a6c87c46fb9a01ca560b4d7",target:"_blank",rel:"noopener noreferrer"}},[t._v("掘金 -- 缓存详解"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.im/post/5be3f486e51d45053d5c38ca",target:"_blank",rel:"noopener noreferrer"}},[t._v("http缓存与cdn缓存配置指南"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://excaliburhan.com/post/things-you-should-know-about-browser-cache.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("你应该知道的浏览器缓存知识"),e("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);